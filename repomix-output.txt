This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-30T04:24:04.134Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
index.html
package.json
postcss.config.js
README.md
src/App.tsx
src/components/Attribution.tsx
src/components/layout/Header.tsx
src/components/layout/Layout.tsx
src/components/LoadingSpinner.tsx
src/components/MovieCard.tsx
src/components/SearchBar.tsx
src/components/StreamingBadge.tsx
src/context/WatchlistContext.tsx
src/env.d.ts
src/index.css
src/index.tsx
src/main.tsx
src/pages/Details.tsx
src/pages/Home.tsx
src/pages/NotFound.tsx
src/pages/Results.tsx
src/pages/Watchlist.tsx
src/services/api.ts
src/services/watchmode.ts
src/types/movie.ts
src/types/props.ts
src/types/streaming.ts
src/types/user.ts
tailwind.config.js
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Repository Files
================================================================

================
File: .gitignore
================
.env
.env.local

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stream Finder</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: package.json
================
{
    "name": "stream-finder",
    "private": true,
    "version": "0.1.0",
    "type": "module",
    "scripts": {
        "start": "vite",
        "dev": "vite",
        "build": "tsc && vite build",
        "preview": "vite preview",
        "lint": "eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0"
    },
    "dependencies": {
        "@heroicons/react": "^2.1.1",
        "axios": "^1.7.9",
        "react": "^18.2.0",
        "react-dom": "^18.2.0",
        "react-router-dom": "^6.21.1"
    },
    "devDependencies": {
        "@types/react": "^18.2.47",
        "@types/react-dom": "^18.2.18",
        "@typescript-eslint/eslint-plugin": "^6.18.1",
        "@typescript-eslint/parser": "^6.18.1",
        "@vitejs/plugin-react-swc": "^3.5.0",
        "autoprefixer": "^10.4.16",
        "eslint": "^8.56.0",
        "eslint-plugin-react-hooks": "^4.6.0",
        "eslint-plugin-react-refresh": "^0.4.5",
        "postcss": "^8.4.33",
        "tailwindcss": "^3.4.1",
        "typescript": "^5.3.3",
        "vite": "^5.0.11"
    }
}

================
File: postcss.config.js
================
// postcss.config.js
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: README.md
================
# Stream Finder

A React-based web application that allows users to search for movies and TV shows and find their streaming availability across different platforms.

## Features

- Search for movies and TV shows
- View streaming availability
- See rental and purchase options
- Save to watchlist (requires authentication)
- Filter and sort results

## Setup

1. Run `npm install`
2. Run `npm start`

## Environment Variables

Create a `.env` file in the root directory with:

```
REACT_APP_API_KEY=your_api_key_here
```

## Available Scripts

- `npm start`: Runs the development server
- `npm test`: Runs tests
- `npm run build`: Builds for production

================
File: src/App.tsx
================
// src/App.tsx
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Layout from './components/layout/Layout';
import Home from './pages/Home';
import Results from './pages/Results';
import Details from './pages/Details';
import Watchlist from './pages/Watchlist';
import NotFound from './pages/NotFound';

function App() {
  return (
    <Router>
      <Layout>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/results" element={<Results />} />
          <Route path="/details/:id" element={<Details />} />
          <Route path="/watchlist" element={<Watchlist />} />
          <Route path="*" element={<NotFound />} />
        </Routes>
      </Layout>
    </Router>
  );
}

export default App;

================
File: src/components/Attribution.tsx
================
// src/components/Attribution.tsx
import React from 'react';

const Attribution: React.FC = () => {
  return (
    <div className="mt-4 text-xs text-gray-500 text-center">
      Streaming data powered by <a href="https://watchmode.com" target="_blank" rel="noopener noreferrer" className="underline">Watchmode.com</a>
    </div>
  );
};

export default Attribution;

================
File: src/components/layout/Header.tsx
================
// src/components/layout/Header.tsx
import React from 'react';
import { Link } from 'react-router-dom';

export const Header: React.FC = () => {
  return (
    <header className="bg-white shadow-sm">
      <div className="container mx-auto px-4 py-4">
        <nav className="flex justify-between items-center">
          <Link to="/" className="text-2xl font-bold text-primary">
            Stream Finder
          </Link>
          <div className="flex gap-4">
            <Link to="/" className="text-gray-600 hover:text-primary">
              Home
            </Link>
            <Link to="/watchlist" className="text-gray-600 hover:text-primary">
              Watchlist
            </Link>
          </div>
        </nav>
      </div>
    </header>
  );
};

export default Header;

================
File: src/components/layout/Layout.tsx
================
// src/components/layout/Layout.tsx
import React from 'react';
import Header from './Header';
import Attribution from '@/components/Attribution';

export const Layout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <div className="min-h-screen bg-gray-50 flex flex-col">
      <Header />
      <main className="container mx-auto px-4 py-8 flex-grow">
        {children}
      </main>
      <footer className="bg-white shadow-inner py-4">
        <div className="container mx-auto px-4 text-xs text-gray-500 text-center">
          <Attribution /> {/* Include Attribution in Footer */}
        </div>
      </footer>
    </div>
  );
};

export default Layout;

================
File: src/components/LoadingSpinner.tsx
================
// src/components/LoadingSpinner.tsx
import React from 'react';

export const LoadingSpinner: React.FC = () => {
  return (
    <div className="flex justify-center items-center min-h-[40vh]">
      <div className="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-primary"></div>
    </div>
  );
};

export default LoadingSpinner;

================
File: src/components/MovieCard.tsx
================
// src/components/MovieCard.tsx
import React, { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import { Movie } from '../types/movie';
import { StreamingInfo, StreamingProvider } from '../types/streaming';
import { useWatchlist } from '../context/WatchlistContext';
import { getStreamingInfo } from '../services/api';
import { BookmarkPlus, BookmarkMinus, ExternalLink } from 'lucide-react';
import Attribution from './Attribution'; // Import Attribution

interface MovieCardProps {
  movie: Movie;
}

/**
 * Displays a badge for a streaming provider.
 */
const ProviderBadge: React.FC<{ 
    provider: StreamingProvider, 
    streamingUrl?: string 
  }> = ({ provider, streamingUrl }) => {
  
  return (
    <div className="flex items-center gap-2 p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors">
      <img 
        src={provider.logo} 
        alt={provider.name} 
        className="w-6 h-6 rounded-full"
      />
      <div className="flex flex-col">
        <span className="font-medium text-sm">{provider.name}</span>
        {provider.requiresSubscription ? (
          <span className="text-xs font-medium text-blue-600">
            Requires Subscription
          </span>
        ) : (
          <span className="text-xs font-medium text-green-600">
            Free
          </span>
        )}
      </div>
      {streamingUrl && (
        <a 
          href={streamingUrl} 
          target="_blank" 
          rel="noopener noreferrer"
          className="ml-auto"
        >
          <ExternalLink className="w-4 h-4 text-gray-500 hover:text-gray-700" />
        </a>
      )}
    </div>
  );
};

/**
 * Displays a section of streaming providers.
 */
const StreamingSection: React.FC<{ 
  title: string;
  providers: StreamingProvider[];
  type: 'stream' | 'rent' | 'buy';
}> = ({ title, providers, type }) => {
  if (!providers || providers.length === 0) return null;

  return (
    <div className="mb-4">
      <h3 className="text-sm font-semibold mb-2">{title}</h3>
      <div className="space-y-2">
        {providers.map((provider, index) => (
          <ProviderBadge
            key={`${provider.id}-${type}-${index}`}
            provider={provider}
            streamingUrl={provider.streamingUrl}
          />
        ))}
      </div>
    </div>
  );
};

/**
 * Represents a single movie card displaying its details and streaming options.
 */
export const MovieCard: React.FC<MovieCardProps> = ({ movie }) => {
  const { isInWatchlist, addToWatchlist, removeFromWatchlist } = useWatchlist();
  const [streamingInfo, setStreamingInfo] = useState<StreamingInfo | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const inWatchlist = isInWatchlist(movie.id);

  useEffect(() => {
    const fetchStreamingInfo = async () => {
      try {
        setLoading(true);
        const info = await getStreamingInfo(movie.id, movie.type);
        setStreamingInfo(info);
        setError(null);
      } catch (err) {
        setError('Error loading streaming options');
        console.error('Error fetching streaming info:', err);
      } finally {
        setLoading(false);
      }
    };

    fetchStreamingInfo();
  }, [movie.id, movie.type]);

  return (
    <div className="bg-white rounded-lg shadow-lg overflow-hidden">
      <Link to={`/details/${movie.id}`}>
        <img
          src={`https://image.tmdb.org/t/p/w500${movie.posterPath}`}
          alt={movie.title}
          className="w-full h-64 object-cover"
        />
      </Link>
      <div className="p-4">
        <div className="flex justify-between items-start mb-2">
          <h3 className="text-lg font-semibold">{movie.title}</h3>
          <button
            onClick={() => inWatchlist ? removeFromWatchlist(movie.id) : addToWatchlist(movie)}
            className="text-gray-600 hover:text-primary"
          >
            {inWatchlist ? (
              <BookmarkMinus className="w-5 h-5" />
            ) : (
              <BookmarkPlus className="w-5 h-5" />
            )}
          </button>
        </div>
        
        <p className="text-sm text-gray-600 mb-4 line-clamp-2">
          {movie.overview}
        </p>
        
        {loading ? (
          <div className="flex justify-center py-4">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
          </div>
        ) : error ? (
          <p className="text-sm text-red-500 text-center">{error}</p>
        ) : (
          <>
            {streamingInfo?.providers.stream && streamingInfo.providers.stream.length > 0 ? (
              <StreamingSection
                title="Available to Stream"
                providers={streamingInfo.providers.stream}
                type="stream"
              />
            ) : (
              <p className="text-gray-500 text-center">Streaming information not available.</p>
            )}
          </>
        )}
        
        <div className="mt-4 pt-4 border-t border-gray-200">
          <span className="text-sm text-gray-500">
            Released: {new Date(movie.releaseDate).getFullYear()}
          </span>
          {movie.rating && (
            <span className="text-sm text-gray-500 ml-4">
              Rating: {movie.rating.toFixed(1)}/10
            </span>
          )}
        </div>

        {/* Attribution Section */}
        {streamingInfo && (
          <Attribution />
        )}
      </div>
    </div>
  );
};

export default MovieCard;

================
File: src/components/SearchBar.tsx
================
// src/components/SearchBar.tsx
import { useState, type FC, type FormEvent, ChangeEvent } from 'react';
import { useNavigate } from 'react-router-dom';

export const SearchBar: FC = () => {
  const [query, setQuery] = useState('');
  const navigate = useNavigate();

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    if (query.trim()) {
      navigate(`/results?q=${encodeURIComponent(query.trim())}`);
    }
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setQuery(e.target.value);
  };

  return (
    <form onSubmit={handleSubmit} className="w-full max-w-2xl mx-auto">
      <div className="relative">
        <input
          type="text"
          value={query}
          onChange={handleChange}
          placeholder="Search for movies or TV shows..."
          className="input-primary w-full pl-12"
        />
        <button type="submit" className="absolute right-2 top-2 btn-primary">
          Search
        </button>
      </div>
    </form>
  );
};

export default SearchBar;

================
File: src/components/StreamingBadge.tsx
================
// src/components/StreamingBadge.tsx
import React from 'react';
import { StreamingProvider } from '../types/streaming';
import { ExternalLink } from 'lucide-react';

interface StreamingBadgeProps {
  provider: StreamingProvider;
  price?: number; // Optional prop
}

/**
 * Displays a badge for a streaming provider with its details.
 */
export const StreamingBadge: React.FC<StreamingBadgeProps> = ({ provider, price }) => {
  return (
    <div className="flex items-center gap-2 bg-gray-100 rounded-full px-4 py-2">
      <img
        src={provider.logo}
        alt={provider.name}
        className="w-6 h-6 rounded-full"
      />
      <span className="font-medium">{provider.name}</span>
      {provider.requiresSubscription ? (
        <span className="text-xs text-blue-600">
          Requires Subscription
        </span>
      ) : (
        <span className="text-xs text-green-600">
          Free
        </span>
      )}
      {price && (
        <span className="text-xs text-gray-600">
          ${price.toFixed(2)}
        </span>
      )}
      {provider.streamingUrl && (
        <a href={provider.streamingUrl} target="_blank" rel="noopener noreferrer" className="ml-auto">
          <ExternalLink className="w-4 h-4 text-gray-500 hover:text-gray-700" />
        </a>
      )}
    </div>
  );
};

export default StreamingBadge;

================
File: src/context/WatchlistContext.tsx
================
// src/context/WatchlistContext.tsx
import React, { createContext, useContext, useState, useCallback } from 'react';
import { Movie } from '../types/movie';

interface WatchlistContextType {
  watchlist: Movie[];
  addToWatchlist: (movie: Movie) => void;
  removeFromWatchlist: (movieId: string) => void;
  isInWatchlist: (movieId: string) => boolean;
}

const WatchlistContext = createContext<WatchlistContextType | undefined>(undefined);

export const WatchlistProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [watchlist, setWatchlist] = useState<Movie[]>([]);

  const addToWatchlist = useCallback((movie: Movie) => {
    setWatchlist((prev) => {
      if (prev.some((m) => m.id === movie.id)) return prev;
      return [...prev, movie];
    });
  }, []);

  const removeFromWatchlist = useCallback((movieId: string) => {
    setWatchlist((prev) => prev.filter((movie) => movie.id !== movieId));
  }, []);

  const isInWatchlist = useCallback(
    (movieId: string) => watchlist.some((movie) => movie.id === movieId),
    [watchlist]
  );

  return (
    <WatchlistContext.Provider
      value={{ watchlist, addToWatchlist, removeFromWatchlist, isInWatchlist }}
    >
      {children}
    </WatchlistContext.Provider>
  );
};

export const useWatchlist = () => {
  const context = useContext(WatchlistContext);
  if (context === undefined) {
    throw new Error('useWatchlist must be used within a WatchlistProvider');
  }
  return context;
};

================
File: src/env.d.ts
================
// src/env.d.ts
/// <reference types="vite/client" />

interface ImportMetaEnv {
    readonly VITE_TMDB_API_KEY: string;
    readonly VITE_WATCHMODE_API_KEY: string;
  }
  
  interface ImportMeta {
    readonly env: ImportMetaEnv;
  }

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer components {
  .btn-primary {
    @apply px-4 py-2 bg-primary text-white rounded-lg hover:bg-opacity-90 transition-all;
  }
  .btn-secondary {
    @apply px-4 py-2 bg-secondary text-white rounded-lg hover:bg-opacity-90 transition-all;
  }
  .input-primary {
    @apply px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:outline-none;
  }
}

================
File: src/index.tsx
================
// src/index.tsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './index.css';
import App from './App';
import { WatchlistProvider } from './context/WatchlistContext';

const container = document.getElementById('root');
if (!container) throw new Error('Failed to find root element');
const root = createRoot(container);

root.render(
  <StrictMode>
    <WatchlistProvider>
      <App />
    </WatchlistProvider>
  </StrictMode>
);

================
File: src/main.tsx
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'
import { WatchlistProvider } from './context/WatchlistContext'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <WatchlistProvider>
      <App />
    </WatchlistProvider>
  </React.StrictMode>,
)

================
File: src/pages/Details.tsx
================
// src/pages/Details.tsx
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { getContentDetails, getStreamingInfo } from '../services/api';
import { Movie } from '../types/movie';
import { StreamingInfo } from '../types/streaming';
import StreamingBadge from '../components/StreamingBadge';
import LoadingSpinner from '../components/LoadingSpinner';
import { useWatchlist } from '../context/WatchlistContext';
import Attribution from '@/components/Attribution';

export const Details: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const [content, setContent] = useState<Movie | null>(null);
  const [streamingInfo, setStreamingInfo] = useState<StreamingInfo | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { isInWatchlist, addToWatchlist, removeFromWatchlist } = useWatchlist();

  useEffect(() => {
    const fetchDetails = async () => {
      if (!id) return;
      try {
        setLoading(true);
        setError(null);
        const contentData = await getContentDetails(id, 'movie'); // Change to 'tv' if necessary
        const streamingData = await getStreamingInfo(id, contentData.type);
        setContent(contentData);
        setStreamingInfo(streamingData);
      } catch (err) {
        setError('Failed to fetch content details. Please try again.');
      } finally {
        setLoading(false);
      }
    };

    fetchDetails();
  }, [id]);

  if (loading) return <LoadingSpinner />;
  if (error) return <div className="text-red-500 text-center">{error}</div>;
  if (!content) return null;

  const inWatchlist = isInWatchlist(content.id);

  return (
    <div className="max-w-4xl mx-auto">
      <div className="flex flex-col md:flex-row gap-8">
        <div className="md:w-1/3">
          <img
            src={`https://image.tmdb.org/t/p/w500${content.posterPath}`}
            alt={content.title}
            className="w-full rounded-lg shadow-lg"
          />
        </div>
        <div className="md:w-2/3">
          <h1 className="text-3xl font-bold mb-4">{content.title}</h1>
          <p className="text-gray-600 mb-6">{content.overview}</p>
          <div className="mb-6">
            <h2 className="text-xl font-semibold mb-4">Streaming Options</h2>
            {streamingInfo?.providers.stream && streamingInfo.providers.stream.length > 0 ? (
              <div className="space-y-4">
                {streamingInfo.providers.stream.map((provider) => (
                  <StreamingBadge key={provider.id} provider={provider} />
                ))}
              </div>
            ) : (
              <p className="text-gray-500">Not available for streaming</p>
            )}

            {/* Attribution Section */}
            {streamingInfo && (
              <Attribution />
            )}
          </div>
          <button
            onClick={() =>
              inWatchlist
                ? removeFromWatchlist(content.id)
                : addToWatchlist(content)
            }
            className={`btn-${inWatchlist ? 'secondary' : 'primary'} w-full`}
          >
            {inWatchlist ? 'Remove from Watchlist' : 'Add to Watchlist'}
          </button>
        </div>
      </div>
    </div>
  );
};

export default Details;

================
File: src/pages/Home.tsx
================
// src/pages/Home.tsx
import React from 'react';
import SearchBar from '../components/SearchBar';

export const Home: React.FC = () => {
  return (
    <div className="flex flex-col items-center justify-center min-h-[80vh]">
      <h1 className="text-4xl font-bold text-center mb-8">
        Find where to watch your favorite movies and shows
      </h1>
      <SearchBar />
    </div>
  );
};

export default Home;

================
File: src/pages/NotFound.tsx
================
// src/pages/NotFound.tsx
import React from 'react';
import { Link } from 'react-router-dom';

export const NotFound: React.FC = () => {
  return (
    <div className="flex flex-col items-center justify-center min-h-[60vh]">
      <h1 className="text-4xl font-bold mb-4">404 - Page Not Found</h1>
      <p className="text-gray-600 mb-8">
        The page you're looking for doesn't exist or has been moved.
      </p>
      <Link to="/" className="btn-primary">
        Return to Home
      </Link>
    </div>
  );
};

export default NotFound;

================
File: src/pages/Results.tsx
================
// src/pages/Results.tsx
import React, { useEffect, useState } from 'react';
import { useSearchParams } from 'react-router-dom';
import { searchContent } from '../services/api';
import { Movie } from '../types/movie';
import MovieCard from '../components/MovieCard';
import LoadingSpinner from '../components/LoadingSpinner';
import Attribution from '@/components/Attribution';

export const Results: React.FC = () => {
  const [searchParams] = useSearchParams();
  const query = searchParams.get('q') || '';
  const [results, setResults] = useState<Movie[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchResults = async () => {
      try {
        setLoading(true);
        setError(null);
        const data = await searchContent(query);
        setResults(data);
      } catch (err) {
        setError('Failed to fetch results. Please try again.');
      } finally {
        setLoading(false);
      }
    };

    if (query) {
      fetchResults();
    }
  }, [query]);

  if (loading) return <LoadingSpinner />;
  if (error) return <div className="text-red-500 text-center">{error}</div>;

  return (
    <div>
      <h2 className="text-2xl font-semibold mb-6">Results for "{query}"</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {results.map((movie) => (
          <MovieCard key={movie.id} movie={movie} />
        ))}
      </div>
      {results.length === 0 && (
        <p className="text-center text-gray-500">No results found.</p>
      )}

      {/* Attribution Section */}
      {results.length > 0 && (
        <Attribution />
      )}
    </div>
  );
};

export default Results;

================
File: src/pages/Watchlist.tsx
================
// src/pages/Watchlist.tsx
import React from 'react';
import { useWatchlist } from '../context/WatchlistContext';
import MovieCard from '../components/MovieCard';
import Attribution from '@/components/Attribution';

export const Watchlist: React.FC = () => {
  const { watchlist } = useWatchlist();

  return (
    <div>
      <h1 className="text-3xl font-bold mb-6">My Watchlist</h1>
      {watchlist.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {watchlist.map((movie) => (
            <MovieCard key={movie.id} movie={movie} />
          ))}
        </div>
      ) : (
        <p className="text-center text-gray-500">
          Your watchlist is empty. Start adding movies and shows!
        </p>
      )}

      {/* Attribution Section */}
      {watchlist.length > 0 && (
        <Attribution />
      )}
    </div>
  );
};

export default Watchlist;

================
File: src/services/api.ts
================
// src/services/api.ts
import axios from 'axios';
import { Movie } from '../types/movie';
import { StreamingInfo } from '../types/streaming';
import { searchContentWatchmode, getStreamingInfoWatchmode } from './watchmode';

const TMDB_API_KEY = import.meta.env.VITE_TMDB_API_KEY;
const TMDB_BASE_URL = 'https://api.themoviedb.org/3';

const api = axios.create({
  baseURL: TMDB_BASE_URL,
  params: {
    api_key: TMDB_API_KEY,
  },
});

/**
 * Searches for movies or TV shows using TMDb API.
 * @param query - The search query.
 * @returns An array of Movie objects.
 */
export const searchContent = async (query: string): Promise<Movie[]> => {
  try {
    const response = await api.get('/search/multi', {
      params: {
        query,
        include_adult: false,
      },
    });

    return response.data.results.map((item: any) => ({
      id: item.id.toString(),
      title: item.title || item.name,
      overview: item.overview,
      posterPath: item.poster_path,
      releaseDate: item.release_date || item.first_air_date,
      type: item.media_type,
      rating: item.vote_average,
    }));
  } catch (error) {
    console.error('Error searching content:', error);
    throw error;
  }
};

/**
 * Retrieves detailed information about a specific movie or TV show.
 * @param id - The TMDb ID of the content.
 * @param type - The type of content ('movie' or 'tv').
 * @returns A Movie object with detailed information.
 */
export const getContentDetails = async (id: string, type: string): Promise<Movie> => {
  try {
    const response = await api.get(`/${type}/${id}`);
    const data = response.data;

    return {
      id: data.id.toString(),
      title: data.title || data.name,
      overview: data.overview,
      posterPath: data.poster_path,
      releaseDate: data.release_date || data.first_air_date,
      type: type as 'movie' | 'tv',
      rating: data.vote_average,
    };
  } catch (error) {
    console.error('Error getting content details:', error);
    throw error;
  }
};

/**
 * Retrieves streaming availability information using Watchmode API.
 * @param movieId - The TMDb ID of the content.
 * @param type - The type of content ('movie' or 'tv').
 * @returns StreamingInfo object containing provider details.
 */
export const getStreamingInfo = async (movieId: string, type: string): Promise<StreamingInfo> => {
  try {
    const contentDetails = await getContentDetails(movieId, type);
    const title = contentDetails.title;
    const year = new Date(contentDetails.releaseDate).getFullYear();
    const country = 'US'; // Modify as needed or make dynamic based on user location

    // Fetch streaming info from Watchmode with additional parameters
    const searchResults = await searchContentWatchmode(title, year, type as 'movie' | 'tv');
    if (searchResults.length === 0) {
      throw new Error('No streaming information found');
    }

    // Use the first result or implement better matching logic
    const watchmodeId = searchResults[0].id;

    const streamingInfo: StreamingInfo = await getStreamingInfoWatchmode(watchmodeId, country);

    // Check if all provider arrays are empty
    if (
      streamingInfo.providers.stream.length === 0 &&
      streamingInfo.providers.rent.length === 0 &&
      streamingInfo.providers.buy.length === 0
    ) {
      throw new Error('No streaming information found');
    }

    return streamingInfo;
  } catch (error: any) {
    console.error('Error getting streaming info:', error.message);
    throw error;
  }
};

================
File: src/services/watchmode.ts
================
// src/services/watchmode.ts
import axios from 'axios';
import { StreamingInfo, StreamingProvider, StreamingOption } from '../types/streaming';

const WATCHMODE_API_KEY = import.meta.env.VITE_WATCHMODE_API_KEY;
const WATCHMODE_BASE_URL = 'https://api.watchmode.com/v1';

/**
 * Interface representing a search result from Watchmode.
 */
interface WatchmodeSearchResult {
  title: string;
  id: number;
  type: 'movie' | 'tv';
  release_year: number;
}

/**
 * Interface representing a streaming source from Watchmode.
 */
interface WatchmodeSource {
  source_id: number;
  name: string;
  type: string; // e.g., 'free', 'sub', etc.
  region: string;
  ios_url: string;
  android_url: string;
  web_url: string;
  url: string;
}

/**
 * Searches for content on Watchmode based on the name, year, and type.
 * @param query - The name to search for.
 * @param year - The release year of the content.
 * @param type - The type of content ('movie' or 'tv').
 * @returns An array of search results.
 */
export const searchContentWatchmode = async (
  query: string,
  year: number,
  type: 'movie' | 'tv'
): Promise<WatchmodeSearchResult[]> => {
  try {
    const response = await axios.get(`${WATCHMODE_BASE_URL}/search/`, {
      params: {
        apiKey: WATCHMODE_API_KEY,
        search_field: 'name',
        search_value: query,
        content_type: type,
        year: year,
      },
    });

    console.log('Watchmode Search API Response:', response.data);

    if (!response.data || !Array.isArray(response.data.title_results)) {
      console.error('No valid `title_results` array found in Watchmode response:', response.data);
      return [];
    }

    return response.data.title_results.map((item: any) => ({
      title: item.name,
      id: item.id,
      type: item.type,
      release_year: item.year,
    }));
  } catch (error: any) {
    console.error('Error searching content on Watchmode:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Retrieves streaming availability information from Watchmode for a specific content ID.
 * @param watchmodeId - The Watchmode ID of the content.
 * @param country - The country code (default is 'US').
 * @returns A StreamingInfo object containing provider details.
 */
export const getStreamingInfoWatchmode = async (
  watchmodeId: number,
  country: string = 'US'
): Promise<StreamingInfo> => {
  try {
    const response = await axios.get(`${WATCHMODE_BASE_URL}/title/${watchmodeId}/sources/`, {
      params: {
        apiKey: WATCHMODE_API_KEY,
        country: country,
      },
    });

    console.log('Watchmode sources API Response:', response.data);

    const sources: WatchmodeSource[] = response.data.sources;

    console.log('Watchmode sources:', sources);

    if (!Array.isArray(sources)) {
      console.error('No valid `sources` array found in Watchmode response:', response.data);
      return {
        movieId: watchmodeId.toString(),
        providers: {
          stream: [],
          rent: [],
          buy: [],
        },
        lastUpdated: new Date().toISOString(),
        region: country,
      };
    }

    // Initialize provider arrays
    const streamingProviders: StreamingProvider[] = [];
    const rentProviders: StreamingOption[] = [];
    const buyProviders: StreamingOption[] = [];

    // Iterate over each source and categorize based on type
    sources.forEach((source) => {
      if (source.name && source.url) {
        const provider: StreamingProvider = {
          id: source.name.toLowerCase().replace(/\s+/g, '-'),
          name: source.name,
          logo: getProviderLogo(source.name),
          requiresSubscription: !isFreeProvider(source.name),
          streamingUrl: source.url,
        };

        switch (source.type.toLowerCase()) {
          case 'stream':
          case 'free':
          case 'sub':
            // Treat 'free' and 'sub' as streaming providers
            streamingProviders.push(provider);
            break;
          case 'rent':
            const rentOption: StreamingOption = {
              provider: provider,
              streamingUrl: source.url,
              // Price is not provided by Watchmode; leave undefined or set to a default if available
            };
            rentProviders.push(rentOption);
            break;
          case 'buy':
            const buyOption: StreamingOption = {
              provider: provider,
              streamingUrl: source.url,
              // Price is not provided by Watchmode; leave undefined or set to a default if available
            };
            buyProviders.push(buyOption);
            break;
          default:
            console.warn(`Unknown source type '${source.type}' encountered.`);
        }
      } else {
        console.warn('Invalid source encountered:', source);
      }
    });

    // Log categorized providers for verification
    console.log('Streaming Providers:', streamingProviders);
    console.log('Rent Providers:', rentProviders);
    console.log('Buy Providers:', buyProviders);

    return {
      movieId: watchmodeId.toString(),
      providers: {
        stream: streamingProviders,
        rent: rentProviders,
        buy: buyProviders,
      },
      lastUpdated: new Date().toISOString(),
      region: country,
    };
  } catch (error: any) {
    console.error('Error fetching streaming info from Watchmode:', error.response?.data || error.message);
    throw error;
  }
};

/**
 * Utility function to map provider names to their respective logo URLs.
 * @param providerName - The name of the streaming provider.
 * @returns The URL of the provider's logo.
 */
const getProviderLogo = (providerName: string): string => {
  const logos: Record<string, string> = {
    'tubi tv': 'https://upload.wikimedia.org/wikipedia/commons/0/0c/Tubi_Logo.svg',
    kanopy: 'https://upload.wikimedia.org/wikipedia/commons/1/1d/Kanopy_logo.svg',
    netflix: 'https://upload.wikimedia.org/wikipedia/commons/0/08/Netflix_2015_logo.svg',
    'amazon prime video': 'https://upload.wikimedia.org/wikipedia/commons/f/fa/Amazon_icon.svg',
    'disney plus': 'https://upload.wikimedia.org/wikipedia/commons/3/3e/Disney%2B_logo.svg',
    hulu: 'https://upload.wikimedia.org/wikipedia/commons/e/e4/Hulu_Logo.svg',
    // Add more providers and their logo URLs as needed
  };

  const key = providerName.toLowerCase().replace(/\s+/g, ' ');
  return logos[key] || 'https://via.placeholder.com/40'; // Placeholder image if logo not found
};

/**
 * Utility function to determine if a provider offers free streaming.
 * @param providerName - The name of the streaming provider.
 * @returns A boolean indicating if the provider is free.
 */
const isFreeProvider = (providerName: string): boolean => {
  const freeProviders = ['tubi tv', 'netflix', 'amazon prime video', 'disney plus', 'hulu']; // Define as needed
  return freeProviders.includes(providerName.toLowerCase());
};

================
File: src/types/movie.ts
================
// src/types/movie.ts
export interface Movie {
    id: string;
    title: string;
    overview: string;
    posterPath: string;
    releaseDate: string;
    type: 'movie' | 'tv';
    rating?: number;
  }

================
File: src/types/props.ts
================
// src/types/props.ts
import { Movie } from './movie';
import { StreamingProvider } from './streaming';

export interface MovieCardProps {
  movie: Movie;
}

export interface StreamingBadgeProps {
  provider: StreamingProvider;
  price?: number;
}

export interface LayoutProps {
  children: React.ReactNode;
}

================
File: src/types/streaming.ts
================
// src/types/streaming.ts

export interface StreamingProvider {
    id: string;
    name: string;
    logo: string;
    requiresSubscription: boolean;
    streamingUrl?: string;
  }
  
  export interface StreamingOption {
    provider: StreamingProvider;
    price?: number; // Made optional to accommodate missing price data
    qualities?: StreamingQuality[];
    streamingUrl?: string;
  }
  
  export interface StreamingInfo {
    movieId: string;
    providers: {
      stream: StreamingProvider[]; // Made non-optional
      rent: StreamingOption[];     // Made non-optional
      buy: StreamingOption[];      // Made non-optional
    };
    lastUpdated?: string; // ISO date string
    region?: string;
  }
  
  /**
   * Represents pricing information for different streaming qualities.
   */
  export interface StreamingQuality {
    type: 'SD' | 'HD' | '4K';
    available: boolean;
    price?: number;
  }
  
  /**
   * Represents metadata for a streaming provider.
   */
  export interface ProviderMetadata {
    id: string;
    name: string;
    technicalName: string; // Used for API calls
    baseUrl: string;
    logoUrl: string;
    pricing?: {
      subscription?: ProviderPricing;
      rental?: ProviderPricing;
      purchase?: ProviderPricing;
    };
  }
  
  export interface ProviderPricing {
    SD?: number;
    HD?: number;
    '4K'?: number;
  }

================
File: src/types/user.ts
================
// src/types/user.ts
export interface User {
    id: string;
    email: string;
    watchlist: string[]; // Array of movie IDs
  }

================
File: tailwind.config.js
================
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: '#1e40af',
        secondary: '#3b82f6',
        accent: '#60a5fa',
      },
    },
  },
  plugins: [],
}

================
File: tsconfig.json
================
{
    "compilerOptions": {
      "target": "ESNext",
      "lib": ["DOM", "DOM.Iterable", "ESNext"],
      "module": "ESNext",
      "skipLibCheck": true,
      "moduleResolution": "bundler",
      "allowImportingTsExtensions": true,
      "resolveJsonModule": true,
      "isolatedModules": true,
      "noEmit": true,
      "jsx": "react-jsx",
      "strict": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "noFallthroughCasesInSwitch": true,
      "allowJs": true,
      "forceConsistentCasingInFileNames": true,
      "types": ["react", "react-dom"],
      "baseUrl": ".",
      "paths": {
        "@/*": ["./src/*"]
      }
    },
    "include": ["src"],
    "references": [{ "path": "./tsconfig.node.json" }]
  }

================
File: tsconfig.node.json
================
{
    "compilerOptions": {
      "composite": true,
      "skipLibCheck": true,
      "module": "ESNext",
      "moduleResolution": "bundler",
      "allowSyntheticDefaultImports": true,
      "esModuleInterop": true
    },
    "include": ["vite.config.ts"]
  }

================
File: vite.config.ts
================
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react-swc';
import path from 'path';

// Optional: Add a console log to verify that Vite is loading this config
console.log('Vite config loaded');

export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    open: true
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  },
  build: {
    rollupOptions: {
      // Optional: Externalize dependencies if needed
      // external: ['some-external-package'],
    }
  }
});
